import { Component, OnInit } from '@angular/core';
import { ScheduledActivity } from 'src/app/models/scheduledActivity/scheduledActivity.model';
import { ScheduledActivityService } from 'src/app/services/scheduleActivity/schedule-activity.service';
import { ActivityService } from 'src/app/services/activity/activity.service';
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';
import jsPDF, * as jspdf from 'jspdf';
import 'jspdf-autotable';
import {UserOptions} from "jspdf-autotable"
import { UserStoreService } from 'src/app/services/user/user-store.service';
import { UserService } from 'src/app/services/user/user.service';
import { ReportsService } from 'src/app/services/reports/reports.service';
import { Report } from 'src/app/models/report/report.model';




@Component({
  selector: 'app-generate-inventory-quantities',
  templateUrl: './generate-inventory-quantities.component.html',
  styleUrls: ['./generate-inventory-quantities.component.scss']
})
export class GenerateInventoryQuantitiesComponent implements OnInit {
  scheduledActivities: ScheduledActivity[] = [];
  searchTerm: string = '';

  generatedPdf: any;
  pdfSrc: SafeResourceUrl = '';

  downloadReport: jsPDF = new jsPDF('portrait', 'px', 'a4');

  totalActivities: number = 0;
  inProgressActivities:number = 0;

  pendingScheduling:number = 0;
  completedActivities:number = 0;

  public fullName: string = "";
  public surname: string = "";

  retrievedUserID: number = 0;




  constructor(private userService: UserService, private reportsService: ReportsService, private userTyService: UserService, private userStore: UserStoreService, private scheduledActivityService: ScheduledActivityService, private modalService: NgbModal, private sanitizer: DomSanitizer) {}

  ngOnInit(): void {
    this.getAllScheduledActivities();

    this.userStore.getFullNameFromStore().subscribe(val => {
      let fullNameFromToken = this.userTyService.getFullNameFromToekn();
      this.fullName = val || fullNameFromToken;
    });

    this.userStore.getUserIdFromStore().subscribe(val => {
      let idFromToken = this.userService.getUserIdFromToken();
      this.retrievedUserID = val || idFromToken;
    });
    
    this.userStore.getSurnameFromStore().subscribe(val => {
      let surnamefromToken = this.userTyService.getSurnameFromToken();
      this.surname = val || surnamefromToken;
    });

  }

  getAllScheduledActivities(): void {
    this.scheduledActivityService.getAllScheduledActivities(this.searchTerm).subscribe({
      next: (activities) => {
        this.scheduledActivities = activities;
        // Count the number of completed activities
        const completeddActivities = this.scheduledActivities.filter(
          (activity) => activity.activityStatus?.activity_Status === 'Completed'
        );
         this.completedActivities = completeddActivities.length;
         // Count the number of inprogress activities
        const inprog = this.scheduledActivities.filter(
          (activity) => activity.activityStatus?.activity_Status === 'In Progress'
        );
         this.inProgressActivities = inprog.length;
        // Count the total number of all activities
         this.totalActivities = this.scheduledActivities.length;
       

        // Count the notstarted activities
        const notstartact = this.scheduledActivities.filter(
          (activity) => activity.activityStatus?.activity_Status === 'Not Started'
        );
         this.pendingScheduling = notstartact.length;


      },
      error: (response) => {
        console.log(response);
      }
    });
  }

  generatePDF() {
    const doc = new (jspdf as any).jsPDF('portrait', 'px', 'a4');
  
    const fullnamee = "Generated By: " + this.fullName + " " + this.surname;
    const date = "Date Generated: " + new Date();
    const title = "Report Name: " + "Inventory Report";
  
    function addHeader(doc: any, isFirstPage: boolean) {
      const headerText = 'SafariSync';
      const headerHeight = 30;
      const headerColor = '#001844';
  
      const pageCount = doc.internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(12);
        doc.setTextColor(255);
        doc.setFillColor(headerColor);
        doc.rect(0, 0, doc.internal.pageSize.getWidth(), headerHeight, 'F');
  
        // Calculate the width of the text
        const textWidth = doc.getStringUnitWidth(headerText) * doc.internal.getFontSize() / doc.internal.scaleFactor;
  
        // Calculate the x position to center the text
        const xPosition = (doc.internal.pageSize.getWidth() - textWidth) / 2;
  
        doc.text(headerText, xPosition, headerHeight / 2);
  
        // Add titles only on the first page
        if (isFirstPage) {
          const titles = [title, fullnamee, date];
          const titleFontSize = 12;
          const titleSpacing = 1; // Adjust the spacing between titles
          const titleStartY = headerHeight + 20; // Adjust the initial Y position
  
          doc.setFontSize(titleFontSize);
          doc.setTextColor(0); // Set title text color to black
  
          // Add different titles underneath each other
          for (let j = 0; j < titles.length; j++) {
            const title = titles[j];
            const titleY = titleStartY + j * (titleFontSize + titleSpacing);
            const titleXPosition = 10; // Adjust this value as needed
            doc.text(title, titleXPosition, titleY);
          }
        }
      }
    }
  
    function addFooter(doc: any) {
      const footerHeight = 30;
      const footerColor = '#FF0000'; // Red color
  
      const pageCount = doc.internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFillColor(footerColor);
        doc.rect(0, doc.internal.pageSize.getHeight() - footerHeight, doc.internal.pageSize.getWidth(), footerHeight, 'F');
        doc.setFontSize(12);
        doc.setTextColor(255);
        doc.text("EPI-USE", 10, doc.internal.pageSize.getHeight() - footerHeight / 2);
  
        // Add the image to the bottom right of the footer
        const imageWidth = 50; // Adjust the width of the image as needed
        const imageHeight = 20; // Adjust the height of the image as needed
        const imageX = doc.internal.pageSize.getWidth() - imageWidth - 10; // Adjust the X position
        const imageY = doc.internal.pageSize.getHeight() - footerHeight + (footerHeight - imageHeight) / 2;
        doc.addImage('/assets/EPI-USE/EPI-USE Logo.jpg', 'jpg', imageX, imageY, imageWidth, imageHeight);
      }
    }
  
      // Filter the activities based on their status
    const completedActivities = this.scheduledActivities.filter(activity =>
      activity.activityStatus?.activity_Status === 'Completed'
    );

    const inProgressActivities = this.scheduledActivities.filter(activity =>
      activity.activityStatus?.activity_Status === 'In Progress'
    );

    const notStartedActivities = this.scheduledActivities.filter(activity =>
      activity.activityStatus?.activity_Status === 'Not Started'
    );

    const totalCompletedActivities = completedActivities.length;
    const totalInProgressActivities = inProgressActivities.length;
    const totalNotStartedActivities = notStartedActivities.length;
    const grandTotal = totalCompletedActivities + totalInProgressActivities + totalNotStartedActivities; // Calculate the grand total


    addHeader(doc, true);
  let startY = 100; // Initial startY value

  // Create a table for completed activities
  if (completedActivities.length > 0) {
    doc.text("Completed Activities", 14, startY);
    doc.autoTable({
      head: [['Name', 'Description']],
      body: completedActivities.map(activity => [activity.activity.activity_Name, activity.activity.activity_Description]),
      startY: startY + 10, // Add vertical spacing
    });
    startY = doc.autoTable.previous.finalY + 15; // Update startY for the next table
  }

  // Create a table for in-progress activities
  if (inProgressActivities.length > 0) {
    doc.text("In Progress Activities", 14, startY);
    doc.autoTable({
      head: [['Name', 'Description']],
      body: inProgressActivities.map(activity => [activity.activity.activity_Name, activity.activity.activity_Description]),
      startY: startY + 10, // Add vertical spacing
    });
    startY = doc.autoTable.previous.finalY + 15; // Update startY for the next table
  }

  // Create a table for not started/ending activities
  if (notStartedActivities.length > 0) {
    doc.text("Not Started/Ending Activities", 14, startY);
    doc.autoTable({
      head: [['Name', 'Description']],
      body: notStartedActivities.map(activity => [activity.activity.activity_Name, activity.activity.activity_Description]),
      startY: startY + 10, // Add vertical spacing
    });
    startY = doc.autoTable.previous.finalY + 15; // Update startY for the next table
  }

 // Create a table for totals
doc.text("Activity Status Totals", 14, startY);
doc.autoTable({
  head: [['Status', 'Total']],
  body: [
    ['Completed', totalCompletedActivities],
    ['In Progress', totalInProgressActivities],
    ['Not Started', totalNotStartedActivities],
    // Add a row for the grand total with bold text
    [{ content: 'Total Number of Scheduled Activites', styles: { fontStyle: 'bold' } }, grandTotal],
  ],
  startY: startY + 15, // Add vertical spacing
});

  addFooter(doc);

  this.generatedPdf = new Blob([doc.output('blob')], { type: 'application/pdf' });

  const blobUrl = URL.createObjectURL(this.generatedPdf);
  this.pdfSrc = this.sanitizer.bypassSecurityTrustResourceUrl(blobUrl);

  this.downloadReport = doc;
  this.SaveReport();

}
  
    
  

  downloadPDF() {
    this.downloadReport.save('Scheduled Activities Report' + ' ' + new Date());
  }

  OpenPDFModal(content: any) {
    const modalRef = this.modalService.open(content, {
      size: 'dialog-centered',
      backdrop: 'static'
    });
  }

  saveReportRequest: Report = {
    report_ID: 0,
    report_Title: '',
    createdAt: new Date(),
    user_ID: 0,
    pdfUrl: ''
  };
  

  async SaveReport() {
    const blobUrl = URL.createObjectURL(this.generatedPdf);
  
    // Convert the blob URL to base64
    const pdfBlob = await fetch(blobUrl).then(response => response.blob());
    const pdfBlobBuffer = await pdfBlob.arrayBuffer();
    const pdfBase64 = btoa(String.fromCharCode(...new Uint8Array(pdfBlobBuffer)));
  
    this.saveReportRequest = {
      report_ID: 0,
      report_Title: 'Scheduled Activities Report',
      createdAt: new Date(),
      user_ID: this.retrievedUserID,
      pdfUrl: pdfBase64 // Add the serialized PDF data here
    };
  
    this.reportsService.SaveReport(this.saveReportRequest)
      .subscribe(
        (response) => {
          console.log('Report saved successfully:', response);
          // Handle success, you can show a success message or perform other actions
        },
        (error) => {
          console.error('Error saving report:', error);
          // Handle error, you can show an error message or perform other actions
        }
      );
  }


}